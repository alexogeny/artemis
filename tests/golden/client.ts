// Auto-generated by Artemis. Do not edit.
export interface CreateItem {
  name: string;
}

export interface ClientOptions {
  fetch?: typeof fetch;
  init?: RequestInit;
}

function interpolatePath(path: string, params?: Record<string, unknown>): string {
  if (!params) {
    return path;
  }
  return path.replace(/\{([^}]+)\}/g, (_, key) => {
    const value = params[key];
    if (value === undefined || value === null) {
      throw new Error(`Missing value for path parameter ${key}`);
    }
    return encodeURIComponent(String(value));
  });
}

function mergeHeaders(base?: HeadersInit, override?: HeadersInit): HeadersInit | undefined {
  if (!base && !override) {
    return undefined;
  }
  const merged = new Headers(base ?? {});
  if (override) {
    new Headers(override).forEach((value, key) => merged.set(key, value));
  }
  return merged;
}

export class ArtemisClient {
  private readonly baseUrl: string;
  private readonly fetchImpl: typeof fetch;
  private readonly defaultInit: RequestInit;

  constructor(baseUrl: string, options: ClientOptions = {}) {
    this.baseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
    this.fetchImpl = options.fetch ?? fetch;
    this.defaultInit = options.init ?? {};
  }

  async createItem(body: CreateItem, init?: RequestInit): Promise<{
}> {
    const url = new URL('/items', this.baseUrl);
    const merged: RequestInit = { ...this.defaultInit, ...init, method: 'POST' };
    const baseHeaders = mergeHeaders(this.defaultInit.headers, init?.headers);
    const headers = mergeHeaders(baseHeaders, { 'content-type': 'application/json' });
    if (headers) {
      merged.headers = headers;
    }
    merged.body = JSON.stringify(body);
    const response = await this.fetchImpl(url.toString(), merged);
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return await response.json() as {
};
  }

  async getItem(path: {
  item_id: number;
}, init?: RequestInit): Promise<{
  [key: string]: {
  };
}> {
    const url = new URL(interpolatePath('/items/{item_id}', path), this.baseUrl);
    const merged: RequestInit = { ...this.defaultInit, ...init, method: 'GET' };
    const baseHeaders = mergeHeaders(this.defaultInit.headers, init?.headers);
    if (baseHeaders) {
      merged.headers = baseHeaders;
    }
    const response = await this.fetchImpl(url.toString(), merged);
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return await response.json() as {
  [key: string]: {
  };
};
  }

  async getPing(init?: RequestInit): Promise<string> {
    const url = new URL('/ping', this.baseUrl);
    const merged: RequestInit = { ...this.defaultInit, ...init, method: 'GET' };
    const baseHeaders = mergeHeaders(this.defaultInit.headers, init?.headers);
    if (baseHeaders) {
      merged.headers = baseHeaders;
    }
    const response = await this.fetchImpl(url.toString(), merged);
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return await response.text() as string;
  }
}
