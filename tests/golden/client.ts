// Auto-generated by Mere. Do not edit.
export interface AuthenticationFlowResponse {
  challenge?: {
  };
  credential_ids?: Array<string>;
  fallback?: {
  };
  flow_token: string;
  next: {
  };
  provider?: {
  };
  session?: {
  };
}

export interface CreateItem {
  name: string;
}

export interface LoginStartRequest {
  email: string;
}

export interface MfaAttempt {
  code: string;
  flow_token: string;
}

export interface PasskeyAttempt {
  credential_id: string;
  flow_token: string;
  signature: string;
}

export interface PasswordAttempt {
  flow_token: string;
  password: string;
}

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';

export interface ClientOptions {
  fetch?: typeof fetch;
  init?: RequestInit;
}

export interface SuspenseResource<T> {
  promise: Promise<T>;
  read(): T;
}

export interface Loadable<T> {
  state: 'idle' | 'loading' | 'success' | 'error';
  data?: T;
  error?: unknown;
  run(): Promise<T>;
}

export interface QueryOptions<T> {
  key?: readonly unknown[];
  enabled?: boolean;
  placeholderData?: T;
}

export interface QueryDescriptor<T> {
  queryKey: readonly unknown[];
  queryFn: () => Promise<T>;
  enabled?: boolean;
  placeholderData?: T;
}

interface RouteRuntime<I, O> {
  method: HttpMethod;
  path: string;
  hasPath: boolean;
  hasBody: boolean;
  mediaType?: string;
  response: 'json' | 'text' | 'void';
  key: (input: I) => readonly unknown[];
}

interface MereClientRuntime {
  request<I, O>(route: RouteRuntime<I, O>, input: I): Promise<O>;
}

export interface RouteHandle<I, O> extends RouteRuntime<I, O> {
  request(client: MereClientRuntime, input: I): Promise<O>;
  suspense(client: MereClientRuntime, input: I): SuspenseResource<O>;
  loadable(client: MereClientRuntime, input: I): Loadable<O>;
  query(
    client: MereClientRuntime,
    input: I,
    options?: QueryOptions<O>
  ): QueryDescriptor<O>;
}

function interpolatePath(path: string, params?: Record<string, unknown>): string {
  if (!params) {
    return path;
  }
  return path.replace(/\{([^}]+)\}/g, (_, key) => {
    const value = params[key];
    if (value === undefined || value === null) {
      throw new Error(`Missing value for path parameter ${key}`);
    }
    return encodeURIComponent(String(value));
  });
}

function mergeHeaders(base?: HeadersInit, override?: HeadersInit): HeadersInit | undefined {
  if (!base && !override) {
    return undefined;
  }
  const merged = new Headers(base ?? {});
  if (override) {
    new Headers(override).forEach((value, key) => merged.set(key, value));
  }
  return merged;
}

function mergeInit(base: RequestInit, override?: RequestInit): RequestInit {
  const merged: RequestInit = { ...base };
  if (override) {
    for (const [key, value] of Object.entries(override)) {
      if (key === 'headers' || key === 'body' || value === undefined) {
        continue;
      }
      (merged as Record<string, unknown>)[key] = value as unknown;
    }
  }
  const headers = mergeHeaders(base.headers, override?.headers);
  if (headers) {
    merged.headers = headers;
  }
  return merged;
}

export class MereHttpError extends Error {
  readonly response: Response;
  readonly status: number;

  constructor(response: Response) {
    super(`Request failed with status ${response.status}`);
    this.name = 'MereHttpError';
    this.response = response;
    this.status = response.status;
  }
}

function createSuspenseResource<T>(promise: Promise<T>): SuspenseResource<T> {
  let status: 'pending' | 'resolved' | 'rejected' = 'pending';
  let result: T;
  let error: unknown;
  const suspender = promise.then(
    (value) => {
      status = 'resolved';
      result = value;
      return value;
    },
    (reason) => {
      status = 'rejected';
      error = reason;
      throw reason;
    }
  );
  return {
    promise: suspender,
    read(): T {
      if (status === 'pending') {
        throw suspender;
      }
      if (status === 'rejected') {
        throw error;
      }
      return result;
    },
  };
}

function createLoadable<T>(executor: () => Promise<T>): Loadable<T> {
  const loadable: Loadable<T> = {
    state: 'idle',
    async run(): Promise<T> {
      loadable.state = 'loading';
      loadable.error = undefined;
      try {
        const value = await executor();
        loadable.state = 'success';
        loadable.data = value;
        return value;
      } catch (err) {
        loadable.state = 'error';
        loadable.error = err;
        throw err;
      }
    },
  };
  return loadable;
}

function createRoute<I, O>(definition: RouteRuntime<I, O>): RouteHandle<I, O> {
  return {
    ...definition,
    request(client: MereClientRuntime, input: I): Promise<O> {
      return client.request(definition, input);
    },
    suspense(client: MereClientRuntime, input: I): SuspenseResource<O> {
      return createSuspenseResource(client.request(definition, input));
    },
    loadable(client: MereClientRuntime, input: I): Loadable<O> {
      return createLoadable(() => client.request(definition, input));
    },
    query(
      client: MereClientRuntime,
      input: I,
      options?: QueryOptions<O>
    ): QueryDescriptor<O> {
      const descriptor: QueryDescriptor<O> = {
        queryKey: options?.key ?? definition.key(input),
        queryFn: () => client.request(definition, input),
      };
      if (options?.enabled !== undefined) {
        descriptor.enabled = options.enabled;
      }
      if (options?.placeholderData !== undefined) {
        descriptor.placeholderData = options.placeholderData;
      }
      return descriptor;
    },
  };
}

export interface MereAuthLoginMfaPostInput {
  body: MfaAttempt;
  init?: RequestInit;
}

export type MereAuthLoginMfaPostOutput = AuthenticationFlowResponse;

const bootstrapLoginMfaRoute = createRoute<MereAuthLoginMfaPostInput, MereAuthLoginMfaPostOutput>({
  method: 'POST',
  path: '/__mere/auth/login/mfa',
  hasPath: false,
  hasBody: true,
  mediaType: 'application/json',
  response: 'json',
  key(input) {
    return ['POST', '/__mere/auth/login/mfa', input.body] as const;
  },
});

export interface MereAuthLoginPasskeyPostInput {
  body: PasskeyAttempt;
  init?: RequestInit;
}

export type MereAuthLoginPasskeyPostOutput = AuthenticationFlowResponse;

const bootstrapLoginPasskeyRoute = createRoute<MereAuthLoginPasskeyPostInput, MereAuthLoginPasskeyPostOutput>({
  method: 'POST',
  path: '/__mere/auth/login/passkey',
  hasPath: false,
  hasBody: true,
  mediaType: 'application/json',
  response: 'json',
  key(input) {
    return ['POST', '/__mere/auth/login/passkey', input.body] as const;
  },
});

export interface MereAuthLoginPasswordPostInput {
  body: PasswordAttempt;
  init?: RequestInit;
}

export type MereAuthLoginPasswordPostOutput = AuthenticationFlowResponse;

const bootstrapLoginPasswordRoute = createRoute<MereAuthLoginPasswordPostInput, MereAuthLoginPasswordPostOutput>({
  method: 'POST',
  path: '/__mere/auth/login/password',
  hasPath: false,
  hasBody: true,
  mediaType: 'application/json',
  response: 'json',
  key(input) {
    return ['POST', '/__mere/auth/login/password', input.body] as const;
  },
});

export interface MereAuthLoginStartPostInput {
  body: LoginStartRequest;
  init?: RequestInit;
}

export type MereAuthLoginStartPostOutput = AuthenticationFlowResponse;

const bootstrapLoginStartRoute = createRoute<MereAuthLoginStartPostInput, MereAuthLoginStartPostOutput>({
  method: 'POST',
  path: '/__mere/auth/login/start',
  hasPath: false,
  hasBody: true,
  mediaType: 'application/json',
  response: 'json',
  key(input) {
    return ['POST', '/__mere/auth/login/start', input.body] as const;
  },
});

export interface MereClientTsGetInput {
  init?: RequestInit;
}

export type MereClientTsGetOutput = void;

const bootstrapClientRoute = createRoute<MereClientTsGetInput, MereClientTsGetOutput>({
  method: 'GET',
  path: '/__mere/client.ts',
  hasPath: false,
  hasBody: false,
  response: 'void',
  key(input) {
    return ['GET', '/__mere/client.ts'] as const;
  },
});

export interface MereOpenapiJsonGetInput {
  init?: RequestInit;
}

export type MereOpenapiJsonGetOutput = void;

const bootstrapOpenapiRoute = createRoute<MereOpenapiJsonGetInput, MereOpenapiJsonGetOutput>({
  method: 'GET',
  path: '/__mere/openapi.json',
  hasPath: false,
  hasBody: false,
  response: 'void',
  key(input) {
    return ['GET', '/__mere/openapi.json'] as const;
  },
});

export interface MerePingGetInput {
  init?: RequestInit;
}

export type MerePingGetOutput = string;

const bootstrapPingRoute = createRoute<MerePingGetInput, MerePingGetOutput>({
  method: 'GET',
  path: '/__mere/ping',
  hasPath: false,
  hasBody: false,
  response: 'text',
  key(input) {
    return ['GET', '/__mere/ping'] as const;
  },
});

export interface ItemsPostInput {
  body: CreateItem;
  init?: RequestInit;
}

export type ItemsPostOutput = {
};

const createItemRoute = createRoute<ItemsPostInput, ItemsPostOutput>({
  method: 'POST',
  path: '/items',
  hasPath: false,
  hasBody: true,
  mediaType: 'application/json',
  response: 'json',
  key(input) {
    return ['POST', '/items', input.body] as const;
  },
});

export interface ItemsItemIdGetInput {
  path: {
  item_id: number;
};
  init?: RequestInit;
}

export type ItemsItemIdGetOutput = {
  [key: string]: {
  };
};

const getItemRoute = createRoute<ItemsItemIdGetInput, ItemsItemIdGetOutput>({
  method: 'GET',
  path: '/items/{item_id}',
  hasPath: true,
  hasBody: false,
  response: 'json',
  key(input) {
    return ['GET', '/items/{item_id}', input.path] as const;
  },
});

export interface PingGetInput {
  init?: RequestInit;
}

export type PingGetOutput = string;

const getPingRoute = createRoute<PingGetInput, PingGetOutput>({
  method: 'GET',
  path: '/ping',
  hasPath: false,
  hasBody: false,
  response: 'text',
  key(input) {
    return ['GET', '/ping'] as const;
  },
});

export const routes = {
  bootstrapLoginMfa: bootstrapLoginMfaRoute,
  bootstrapLoginPasskey: bootstrapLoginPasskeyRoute,
  bootstrapLoginPassword: bootstrapLoginPasswordRoute,
  bootstrapLoginStart: bootstrapLoginStartRoute,
  bootstrapClient: bootstrapClientRoute,
  bootstrapOpenapi: bootstrapOpenapiRoute,
  bootstrapPing: bootstrapPingRoute,
  createItem: createItemRoute,
  getItem: getItemRoute,
  getPing: getPingRoute,
} as const;

export class MereClient implements MereClientRuntime {
  private readonly baseUrl: string;
  private readonly fetchImpl: typeof fetch;
  private readonly defaultInit: RequestInit;

  constructor(baseUrl: string, options: ClientOptions = {}) {
    this.baseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
    this.fetchImpl = options.fetch ?? fetch;
    this.defaultInit = options.init ?? {};
  }

  async request<I, O>(route: RouteRuntime<I, O>, input: I): Promise<O> {
    const params = route.hasPath ? (input as Record<string, unknown>).path : undefined;
    const resolved = route.hasPath
      ? interpolatePath(route.path, params as Record<string, unknown>)
      : route.path;
    const url = new URL(resolved, this.baseUrl);
    const init = this.composeInit(route, input);
    const response = await this.fetchImpl(url.toString(), init);
    if (!response.ok) {
      throw new MereHttpError(response);
    }
    return this.parseResponse(route, response);
  }

  private composeInit<I>(route: RouteRuntime<I, unknown>, input: I): RequestInit {
    const override = (input as Record<string, unknown>).init as RequestInit | undefined;
    const merged = mergeInit(this.defaultInit, override);
    merged.method = route.method;
    if (route.hasBody) {
      const body = (input as Record<string, unknown>).body;
      if (route.mediaType === 'application/json') {
        merged.body = JSON.stringify(body ?? null);
      } else if (body !== undefined) {
        merged.body = body as BodyInit;
      }
      if (route.mediaType) {
        merged.headers = mergeHeaders(merged.headers, { 'content-type': route.mediaType });
      }
    }
    return merged;
  }

  private async parseResponse<I, O>(route: RouteRuntime<I, O>, response: Response): Promise<O> {
    if (route.response === 'void') {
      return undefined as O;
    }
    if (route.response === 'text') {
      return (await response.text()) as unknown as O;
    }
    return (await response.json()) as O;
  }

  async bootstrapLoginMfa(input: MereAuthLoginMfaPostInput): Promise<MereAuthLoginMfaPostOutput> {
    return bootstrapLoginMfaRoute.request(this, input);
  }

  bootstrapLoginMfaSuspense(input: MereAuthLoginMfaPostInput): SuspenseResource<MereAuthLoginMfaPostOutput> {
    return bootstrapLoginMfaRoute.suspense(this, input);
  }

  bootstrapLoginMfaLoadable(input: MereAuthLoginMfaPostInput): Loadable<MereAuthLoginMfaPostOutput> {
    return bootstrapLoginMfaRoute.loadable(this, input);
  }

  bootstrapLoginMfaQuery(
    input: MereAuthLoginMfaPostInput,
    options?: QueryOptions<MereAuthLoginMfaPostOutput>,
  ): QueryDescriptor<MereAuthLoginMfaPostOutput> {
    return bootstrapLoginMfaRoute.query(this, input, options);
  }

  async bootstrapLoginPasskey(input: MereAuthLoginPasskeyPostInput): Promise<MereAuthLoginPasskeyPostOutput> {
    return bootstrapLoginPasskeyRoute.request(this, input);
  }

  bootstrapLoginPasskeySuspense(input: MereAuthLoginPasskeyPostInput): SuspenseResource<MereAuthLoginPasskeyPostOutput> {
    return bootstrapLoginPasskeyRoute.suspense(this, input);
  }

  bootstrapLoginPasskeyLoadable(input: MereAuthLoginPasskeyPostInput): Loadable<MereAuthLoginPasskeyPostOutput> {
    return bootstrapLoginPasskeyRoute.loadable(this, input);
  }

  bootstrapLoginPasskeyQuery(
    input: MereAuthLoginPasskeyPostInput,
    options?: QueryOptions<MereAuthLoginPasskeyPostOutput>,
  ): QueryDescriptor<MereAuthLoginPasskeyPostOutput> {
    return bootstrapLoginPasskeyRoute.query(this, input, options);
  }

  async bootstrapLoginPassword(input: MereAuthLoginPasswordPostInput): Promise<MereAuthLoginPasswordPostOutput> {
    return bootstrapLoginPasswordRoute.request(this, input);
  }

  bootstrapLoginPasswordSuspense(input: MereAuthLoginPasswordPostInput): SuspenseResource<MereAuthLoginPasswordPostOutput> {
    return bootstrapLoginPasswordRoute.suspense(this, input);
  }

  bootstrapLoginPasswordLoadable(input: MereAuthLoginPasswordPostInput): Loadable<MereAuthLoginPasswordPostOutput> {
    return bootstrapLoginPasswordRoute.loadable(this, input);
  }

  bootstrapLoginPasswordQuery(
    input: MereAuthLoginPasswordPostInput,
    options?: QueryOptions<MereAuthLoginPasswordPostOutput>,
  ): QueryDescriptor<MereAuthLoginPasswordPostOutput> {
    return bootstrapLoginPasswordRoute.query(this, input, options);
  }

  async bootstrapLoginStart(input: MereAuthLoginStartPostInput): Promise<MereAuthLoginStartPostOutput> {
    return bootstrapLoginStartRoute.request(this, input);
  }

  bootstrapLoginStartSuspense(input: MereAuthLoginStartPostInput): SuspenseResource<MereAuthLoginStartPostOutput> {
    return bootstrapLoginStartRoute.suspense(this, input);
  }

  bootstrapLoginStartLoadable(input: MereAuthLoginStartPostInput): Loadable<MereAuthLoginStartPostOutput> {
    return bootstrapLoginStartRoute.loadable(this, input);
  }

  bootstrapLoginStartQuery(
    input: MereAuthLoginStartPostInput,
    options?: QueryOptions<MereAuthLoginStartPostOutput>,
  ): QueryDescriptor<MereAuthLoginStartPostOutput> {
    return bootstrapLoginStartRoute.query(this, input, options);
  }

  async bootstrapClient(input: MereClientTsGetInput): Promise<MereClientTsGetOutput> {
    return bootstrapClientRoute.request(this, input);
  }

  bootstrapClientSuspense(input: MereClientTsGetInput): SuspenseResource<MereClientTsGetOutput> {
    return bootstrapClientRoute.suspense(this, input);
  }

  bootstrapClientLoadable(input: MereClientTsGetInput): Loadable<MereClientTsGetOutput> {
    return bootstrapClientRoute.loadable(this, input);
  }

  bootstrapClientQuery(
    input: MereClientTsGetInput,
    options?: QueryOptions<MereClientTsGetOutput>,
  ): QueryDescriptor<MereClientTsGetOutput> {
    return bootstrapClientRoute.query(this, input, options);
  }

  async bootstrapOpenapi(input: MereOpenapiJsonGetInput): Promise<MereOpenapiJsonGetOutput> {
    return bootstrapOpenapiRoute.request(this, input);
  }

  bootstrapOpenapiSuspense(input: MereOpenapiJsonGetInput): SuspenseResource<MereOpenapiJsonGetOutput> {
    return bootstrapOpenapiRoute.suspense(this, input);
  }

  bootstrapOpenapiLoadable(input: MereOpenapiJsonGetInput): Loadable<MereOpenapiJsonGetOutput> {
    return bootstrapOpenapiRoute.loadable(this, input);
  }

  bootstrapOpenapiQuery(
    input: MereOpenapiJsonGetInput,
    options?: QueryOptions<MereOpenapiJsonGetOutput>,
  ): QueryDescriptor<MereOpenapiJsonGetOutput> {
    return bootstrapOpenapiRoute.query(this, input, options);
  }

  async bootstrapPing(input: MerePingGetInput): Promise<MerePingGetOutput> {
    return bootstrapPingRoute.request(this, input);
  }

  bootstrapPingSuspense(input: MerePingGetInput): SuspenseResource<MerePingGetOutput> {
    return bootstrapPingRoute.suspense(this, input);
  }

  bootstrapPingLoadable(input: MerePingGetInput): Loadable<MerePingGetOutput> {
    return bootstrapPingRoute.loadable(this, input);
  }

  bootstrapPingQuery(
    input: MerePingGetInput,
    options?: QueryOptions<MerePingGetOutput>,
  ): QueryDescriptor<MerePingGetOutput> {
    return bootstrapPingRoute.query(this, input, options);
  }

  async createItem(input: ItemsPostInput): Promise<ItemsPostOutput> {
    return createItemRoute.request(this, input);
  }

  createItemSuspense(input: ItemsPostInput): SuspenseResource<ItemsPostOutput> {
    return createItemRoute.suspense(this, input);
  }

  createItemLoadable(input: ItemsPostInput): Loadable<ItemsPostOutput> {
    return createItemRoute.loadable(this, input);
  }

  createItemQuery(
    input: ItemsPostInput,
    options?: QueryOptions<ItemsPostOutput>,
  ): QueryDescriptor<ItemsPostOutput> {
    return createItemRoute.query(this, input, options);
  }

  async getItem(input: ItemsItemIdGetInput): Promise<ItemsItemIdGetOutput> {
    return getItemRoute.request(this, input);
  }

  getItemSuspense(input: ItemsItemIdGetInput): SuspenseResource<ItemsItemIdGetOutput> {
    return getItemRoute.suspense(this, input);
  }

  getItemLoadable(input: ItemsItemIdGetInput): Loadable<ItemsItemIdGetOutput> {
    return getItemRoute.loadable(this, input);
  }

  getItemQuery(
    input: ItemsItemIdGetInput,
    options?: QueryOptions<ItemsItemIdGetOutput>,
  ): QueryDescriptor<ItemsItemIdGetOutput> {
    return getItemRoute.query(this, input, options);
  }

  async getPing(input: PingGetInput): Promise<PingGetOutput> {
    return getPingRoute.request(this, input);
  }

  getPingSuspense(input: PingGetInput): SuspenseResource<PingGetOutput> {
    return getPingRoute.suspense(this, input);
  }

  getPingLoadable(input: PingGetInput): Loadable<PingGetOutput> {
    return getPingRoute.loadable(this, input);
  }

  getPingQuery(
    input: PingGetInput,
    options?: QueryOptions<PingGetOutput>,
  ): QueryDescriptor<PingGetOutput> {
    return getPingRoute.query(this, input, options);
  }
}
