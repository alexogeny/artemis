"""Generate TypeScript clients from OpenAPI specifications."""

from __future__ import annotations

import json
import re
from typing import Any, Mapping


def generate_typescript_client(spec: Mapping[str, Any]) -> str:
    """Render a fetch-based TypeScript client for ``spec``."""

    emitter = _TypeScriptEmitter(spec)
    return emitter.render()


class _TypeScriptEmitter:
    def __init__(self, spec: Mapping[str, Any]) -> None:
        self.spec = spec
        self.components: Mapping[str, Any] = spec.get("components", {}).get("schemas", {})
        self.renderer = _SchemaRenderer(self.components)

    def render(self) -> str:
        lines: list[str] = ["// Auto-generated by Artemis. Do not edit."]
        if self.components:
            for name, schema in sorted(self.components.items()):
                lines.extend(self.renderer.render_component(name, schema))
                lines.append("")
        lines.extend(
            [
                "export interface ClientOptions {",
                "  fetch?: typeof fetch;",
                "  init?: RequestInit;",
                "}",
                "",
                "function interpolatePath(path: string, params?: Record<string, unknown>): string {",
                "  if (!params) {",
                "    return path;",
                "  }",
                "  return path.replace(/\\{([^}]+)\\}/g, (_, key) => {",
                "    const value = params[key];",
                "    if (value === undefined || value === null) {",
                "      throw new Error(`Missing value for path parameter ${key}`);",
                "    }",
                "    return encodeURIComponent(String(value));",
                "  });",
                "}",
                "",
                "function mergeHeaders(base?: HeadersInit, override?: HeadersInit): HeadersInit | undefined {",
                "  if (!base && !override) {",
                "    return undefined;",
                "  }",
                "  const merged = new Headers(base ?? {});",
                "  if (override) {",
                "    new Headers(override).forEach((value, key) => merged.set(key, value));",
                "  }",
                "  return merged;",
                "}",
                "",
                "export class ArtemisClient {",
                "  private readonly baseUrl: string;",
                "  private readonly fetchImpl: typeof fetch;",
                "  private readonly defaultInit: RequestInit;",
                "",
                "  constructor(baseUrl: string, options: ClientOptions = {}) {",
                "    this.baseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;",
                "    this.fetchImpl = options.fetch ?? fetch;",
                "    this.defaultInit = options.init ?? {};",
                "  }",
            ]
        )
        for path, operations in sorted(self.spec.get("paths", {}).items()):
            for method, operation in sorted(operations.items()):
                lines.extend(self._render_operation(path, method.upper(), operation))
        lines.append("}")
        return "\n".join(lines).rstrip() + "\n"

    def _render_operation(self, path: str, method: str, operation: Mapping[str, Any]) -> list[str]:
        name = _sanitize_operation_id(operation.get("operationId", f"{method.lower()}_{path}"))
        parameters = operation.get("parameters", [])
        path_parameters = [param for param in parameters if param.get("in") == "path"]
        request_body = _select_request_body(operation)
        status_code, response = _select_response(operation)
        response_type, response_handler = self._response_type(response, status_code)
        signature_parts: list[str] = []
        if path_parameters:
            path_schema = {
                "type": "object",
                "properties": {param["name"]: param.get("schema", {}) for param in path_parameters},
                "required": [param["name"] for param in path_parameters],
            }
            signature_parts.append(f"path: {self.renderer.render_type(path_schema)}")
        body_schema = None
        body_media_type = None
        if request_body is not None:
            body_media_type, body_schema = request_body
            signature_parts.append(f"body: {self.renderer.render_type(body_schema)}")
        signature_parts.append("init?: RequestInit")
        signature = ", ".join(signature_parts)
        lines = ["", f"  async {name}({signature}): Promise<{response_type}> {{"]
        if path_parameters:
            lines.append(f"    const url = new URL(interpolatePath('{path}', path), this.baseUrl);")
        else:
            lines.append(f"    const url = new URL('{path}', this.baseUrl);")
        lines.append("    const merged: RequestInit = { ...this.defaultInit, ...init, method: '%s' };" % method)
        lines.append("    const baseHeaders = mergeHeaders(this.defaultInit.headers, init?.headers);")
        if body_schema is not None:
            lines.append(
                f"    const headers = mergeHeaders(baseHeaders, {{ 'content-type': '{body_media_type}' }});"
            )
            lines.append("    if (headers) {")
            lines.append("      merged.headers = headers;")
            lines.append("    }")
            lines.append("    merged.body = JSON.stringify(body);")
        else:
            lines.append("    if (baseHeaders) {")
            lines.append("      merged.headers = baseHeaders;")
            lines.append("    }")
        lines.append("    const response = await this.fetchImpl(url.toString(), merged);")
        lines.append("    if (!response.ok) {")
        lines.append("      throw new Error(`Request failed with status ${response.status}`);")
        lines.append("    }")
        if response_handler == "void":
            lines.append("    return;")
        elif response_handler == "text":
            lines.append(f"    return await response.text() as {response_type};")
        else:
            lines.append(f"    return await response.json() as {response_type};")
        lines.append("  }")
        return lines

    def _response_type(self, response: Mapping[str, Any], status: str) -> tuple[str, str]:
        if status == "204" or not isinstance(response, Mapping):
            return "void", "void"
        content = response.get("content", {})
        if not content:
            return "void", "void"
        media, schema_wrapper = next(iter(content.items()))
        schema = schema_wrapper.get("schema", {})
        ts_type = self.renderer.render_type(schema)
        if media == "text/plain":
            return ts_type, "text"
        return ts_type, "json"


class _SchemaRenderer:
    def __init__(self, components: Mapping[str, Any]) -> None:
        self.components = components

    def render_component(self, name: str, schema: Mapping[str, Any]) -> list[str]:
        if schema.get("type") == "object" or schema.get("properties"):
            body = self.render_type(schema)
            return [f"export interface {name} {body}"]
        return [f"export type {name} = {self.render_type(schema)};"]

    def render_type(self, schema: Mapping[str, Any], level: int = 1) -> str:
        if "$ref" in schema:
            return schema["$ref"].split("/")[-1]
        if "anyOf" in schema:
            return " | ".join(self.render_type(item, level) for item in schema["anyOf"])
        if "enum" in schema:
            return " | ".join(json.dumps(value) for value in schema["enum"])
        if "const" in schema:
            return json.dumps(schema["const"])
        schema_type = schema.get("type")
        if isinstance(schema_type, list):
            return " | ".join(self.render_type({"type": item}) for item in schema_type)
        if schema_type == "object" or schema.get("properties"):
            return self._render_object(schema, level)
        if schema_type == "array":
            item_schema = schema.get("items", {})
            return f"Array<{self.render_type(item_schema, level)}>"
        if schema_type == "string":
            return "string"
        if schema_type == "integer" or schema_type == "number":
            return "number"
        if schema_type == "boolean":
            return "boolean"
        if schema_type == "null":
            return "null"
        return "unknown"

    def _render_object(self, schema: Mapping[str, Any], level: int) -> str:
        indent = "  " * level
        closing_indent = "  " * (level - 1)
        lines = ["{"]
        properties = schema.get("properties", {})
        required = set(schema.get("required", []))
        for key in sorted(properties):
            optional = "?" if key not in required else ""
            prop_type = self.render_type(properties[key], level + 1)
            lines.append(f"{indent}{key}{optional}: {prop_type};")
        additional = schema.get("additionalProperties")
        if additional:
            add_type = self.render_type(additional, level + 1)
            lines.append(f"{indent}[key: string]: {add_type};")
        lines.append(f"{closing_indent}}}")
        return "\n".join(lines)


def _sanitize_operation_id(operation_id: str) -> str:
    parts = [part for part in re.split(r"[^0-9a-zA-Z]+", operation_id) if part]
    if not parts:
        return "operation"
    head, *tail = parts
    candidate = head.lower() + "".join(segment.capitalize() for segment in tail)
    if candidate[0].isdigit():
        candidate = f"op_{candidate}"
    return candidate


def _select_request_body(operation: Mapping[str, Any]) -> tuple[str, Mapping[str, Any]] | None:
    request_body = operation.get("requestBody")
    if not request_body:
        return None
    content = request_body.get("content", {})
    if "application/json" in content:
        schema = content["application/json"].get("schema", {})
        return "application/json", schema
    if content:
        _, value = next(iter(content.items()))
        return _, value.get("schema", {})
    return None


def _select_response(operation: Mapping[str, Any]) -> tuple[str, Mapping[str, Any]]:
    responses = operation.get("responses", {})
    if "200" in responses:
        return "200", responses["200"]
    for status in sorted(responses):
        if status.startswith("2"):
            return status, responses[status]
    return "200", {"description": "Success"}


__all__ = ["generate_typescript_client"]
