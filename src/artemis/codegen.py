"""Generate TypeScript clients from OpenAPI specifications."""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from typing import Any, Mapping


def generate_typescript_client(spec: Mapping[str, Any]) -> str:
    """Render a fetch-based TypeScript client for ``spec``."""

    emitter = _TypeScriptEmitter(spec)
    return emitter.render()


@dataclass(slots=True)
class _OperationMetadata:
    name: str
    type_base: str
    input_type: str
    output_type: str
    route_const: str
    method: str
    path: str
    has_path: bool
    has_body: bool
    media_type: str | None
    response_mode: str
    response_type: str
    key_expr: str
    path_schema: Mapping[str, Any] | None
    body_schema: Mapping[str, Any] | None


class _TypeScriptEmitter:
    def __init__(self, spec: Mapping[str, Any]) -> None:
        self.spec = spec
        self.components: Mapping[str, Any] = spec.get("components", {}).get("schemas", {})
        self.renderer = _SchemaRenderer(self.components)
        self._client_methods: list[str] = []
        self._route_handles: list[tuple[str, str]] = []

    def render(self) -> str:
        lines: list[str] = ["// Auto-generated by Artemis. Do not edit."]
        if self.components:
            for name, schema in sorted(self.components.items()):
                lines.extend(self.renderer.render_component(name, schema))
                lines.append("")
        lines.extend(self._runtime_lines())
        operations = self.spec.get("paths", {})
        for path, methods in sorted(operations.items()):
            for method, operation in sorted(methods.items()):
                meta = self._operation_metadata(path, method.upper(), operation)
                lines.extend(self._render_operation(meta))
        if self._route_handles:
            lines.append("")
            lines.extend(self._render_routes_export())
        lines.append("")
        lines.extend(self._render_client_class())
        return "\n".join(line.rstrip() for line in lines if line is not None).rstrip() + "\n"

    def _runtime_lines(self) -> list[str]:
        return [
            "export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';",
            "",
            "export interface ClientOptions {",
            "  fetch?: typeof fetch;",
            "  init?: RequestInit;",
            "}",
            "",
            "export interface SuspenseResource<T> {",
            "  promise: Promise<T>;",
            "  read(): T;",
            "}",
            "",
            "export interface Loadable<T> {",
            "  state: 'idle' | 'loading' | 'success' | 'error';",
            "  data?: T;",
            "  error?: unknown;",
            "  run(): Promise<T>;",
            "}",
            "",
            "export interface QueryOptions<T> {",
            "  key?: readonly unknown[];",
            "  enabled?: boolean;",
            "  placeholderData?: T;",
            "}",
            "",
            "export interface QueryDescriptor<T> {",
            "  queryKey: readonly unknown[];",
            "  queryFn: () => Promise<T>;",
            "  enabled?: boolean;",
            "  placeholderData?: T;",
            "}",
            "",
            "interface RouteRuntime<I, O> {",
            "  method: HttpMethod;",
            "  path: string;",
            "  hasPath: boolean;",
            "  hasBody: boolean;",
            "  mediaType?: string;",
            "  response: 'json' | 'text' | 'void';",
            "  key: (input: I) => readonly unknown[];",
            "}",
            "",
            "interface ArtemisClientRuntime {",
            "  request<I, O>(route: RouteRuntime<I, O>, input: I): Promise<O>;",
            "}",
            "",
            "export interface RouteHandle<I, O> extends RouteRuntime<I, O> {",
            "  request(client: ArtemisClientRuntime, input: I): Promise<O>;",
            "  suspense(client: ArtemisClientRuntime, input: I): SuspenseResource<O>;",
            "  loadable(client: ArtemisClientRuntime, input: I): Loadable<O>;",
            "  query(",
            "    client: ArtemisClientRuntime,",
            "    input: I,",
            "    options?: QueryOptions<O>",
            "  ): QueryDescriptor<O>;",
            "}",
            "",
            "function interpolatePath(path: string, params?: Record<string, unknown>): string {",
            "  if (!params) {",
            "    return path;",
            "  }",
            "  return path.replace(/\\{([^}]+)\\}/g, (_, key) => {",
            "    const value = params[key];",
            "    if (value === undefined || value === null) {",
            "      throw new Error(`Missing value for path parameter ${key}`);",
            "    }",
            "    return encodeURIComponent(String(value));",
            "  });",
            "}",
            "",
            "function mergeHeaders(base?: HeadersInit, override?: HeadersInit): HeadersInit | undefined {",
            "  if (!base && !override) {",
            "    return undefined;",
            "  }",
            "  const merged = new Headers(base ?? {});",
            "  if (override) {",
            "    new Headers(override).forEach((value, key) => merged.set(key, value));",
            "  }",
            "  return merged;",
            "}",
            "",
            "function mergeInit(base: RequestInit, override?: RequestInit): RequestInit {",
            "  const merged: RequestInit = { ...base };",
            "  if (override) {",
            "    for (const [key, value] of Object.entries(override)) {",
            "      if (key === 'headers' || key === 'body' || value === undefined) {",
            "        continue;",
            "      }",
            "      (merged as Record<string, unknown>)[key] = value as unknown;",
            "    }",
            "  }",
            "  const headers = mergeHeaders(base.headers, override?.headers);",
            "  if (headers) {",
            "    merged.headers = headers;",
            "  }",
            "  return merged;",
            "}",
            "",
            "export class ArtemisHttpError extends Error {",
            "  readonly response: Response;",
            "  readonly status: number;",
            "",
            "  constructor(response: Response) {",
            "    super(`Request failed with status ${response.status}`);",
            "    this.name = 'ArtemisHttpError';",
            "    this.response = response;",
            "    this.status = response.status;",
            "  }",
            "}",
            "",
            "function createSuspenseResource<T>(promise: Promise<T>): SuspenseResource<T> {",
            "  let status: 'pending' | 'resolved' | 'rejected' = 'pending';",
            "  let result: T;",
            "  let error: unknown;",
            "  const suspender = promise.then(",
            "    (value) => {",
            "      status = 'resolved';",
            "      result = value;",
            "      return value;",
            "    },",
            "    (reason) => {",
            "      status = 'rejected';",
            "      error = reason;",
            "      throw reason;",
            "    }",
            "  );",
            "  return {",
            "    promise: suspender,",
            "    read(): T {",
            "      if (status === 'pending') {",
            "        throw suspender;",
            "      }",
            "      if (status === 'rejected') {",
            "        throw error;",
            "      }",
            "      return result;",
            "    },",
            "  };",
            "}",
            "",
            "function createLoadable<T>(executor: () => Promise<T>): Loadable<T> {",
            "  const loadable: Loadable<T> = {",
            "    state: 'idle',",
            "    async run(): Promise<T> {",
            "      loadable.state = 'loading';",
            "      loadable.error = undefined;",
            "      try {",
            "        const value = await executor();",
            "        loadable.state = 'success';",
            "        loadable.data = value;",
            "        return value;",
            "      } catch (err) {",
            "        loadable.state = 'error';",
            "        loadable.error = err;",
            "        throw err;",
            "      }",
            "    },",
            "  };",
            "  return loadable;",
            "}",
            "",
            "function createRoute<I, O>(definition: RouteRuntime<I, O>): RouteHandle<I, O> {",
            "  return {",
            "    ...definition,",
            "    request(client: ArtemisClientRuntime, input: I): Promise<O> {",
            "      return client.request(definition, input);",
            "    },",
            "    suspense(client: ArtemisClientRuntime, input: I): SuspenseResource<O> {",
            "      return createSuspenseResource(client.request(definition, input));",
            "    },",
            "    loadable(client: ArtemisClientRuntime, input: I): Loadable<O> {",
            "      return createLoadable(() => client.request(definition, input));",
            "    },",
            "    query(",
            "      client: ArtemisClientRuntime,",
            "      input: I,",
            "      options?: QueryOptions<O>",
            "    ): QueryDescriptor<O> {",
            "      const descriptor: QueryDescriptor<O> = {",
            "        queryKey: options?.key ?? definition.key(input),",
            "        queryFn: () => client.request(definition, input),",
            "      };",
            "      if (options?.enabled !== undefined) {",
            "        descriptor.enabled = options.enabled;",
            "      }",
            "      if (options?.placeholderData !== undefined) {",
            "        descriptor.placeholderData = options.placeholderData;",
            "      }",
            "      return descriptor;",
            "    },",
            "  };",
            "}",
        ]

    def _operation_metadata(
        self, path: str, method: str, operation: Mapping[str, Any]
    ) -> _OperationMetadata:
        name = _sanitize_operation_id(operation.get("operationId", f"{method.lower()}_{path}"))
        type_base = _type_name_from_path(path, method)
        input_type = f"{type_base}Input"
        output_type = f"{type_base}Output"
        route_const = f"{name}Route"

        parameters = operation.get("parameters", [])
        path_parameters = [param for param in parameters if param.get("in") == "path"]
        path_schema: Mapping[str, Any] | None = None
        if path_parameters:
            path_schema = {
                "type": "object",
                "properties": {param["name"]: param.get("schema", {}) for param in path_parameters},
                "required": [param["name"] for param in path_parameters],
            }

        request_body = _select_request_body(operation)
        body_schema: Mapping[str, Any] | None = None
        media_type: str | None = None
        if request_body is not None:
            media_type, body_schema = request_body

        status_code, response = _select_response(operation)
        response_type, response_mode = self._response_type(response, status_code)

        key_parts = [f"'{method}'", f"'{path}'"]
        if path_parameters:
            key_parts.append("input.path")
        if body_schema is not None:
            key_parts.append("input.body")
        key_expr = "[" + ", ".join(key_parts) + "] as const"

        return _OperationMetadata(
            name=name,
            type_base=type_base,
            input_type=input_type,
            output_type=output_type,
            route_const=route_const,
            method=method,
            path=path,
            has_path=bool(path_parameters),
            has_body=body_schema is not None,
            media_type=media_type,
            response_mode=response_mode,
            response_type=response_type,
            key_expr=key_expr,
            path_schema=path_schema,
            body_schema=body_schema,
        )

    def _render_operation(self, meta: _OperationMetadata) -> list[str]:
        lines: list[str] = [""]
        lines.extend(self._render_input_type(meta))
        lines.append("")
        lines.append(f"export type {meta.output_type} = {meta.response_type};")
        lines.append("")
        lines.extend(self._render_route_constant(meta))
        self._route_handles.append((meta.name, meta.route_const))
        self._append_client_methods(meta)
        return lines

    def _render_input_type(self, meta: _OperationMetadata) -> list[str]:
        lines = [f"export interface {meta.input_type} {{"]
        if meta.has_path and meta.path_schema is not None:
            path_type = self.renderer.render_type(meta.path_schema)
            lines.append(f"  path: {path_type};")
        if meta.has_body and meta.body_schema is not None:
            body_type = self.renderer.render_type(meta.body_schema)
            lines.append(f"  body: {body_type};")
        lines.append("  init?: RequestInit;")
        lines.append("}")
        return lines

    def _render_route_constant(self, meta: _OperationMetadata) -> list[str]:
        lines = [
            f"const {meta.route_const} = createRoute<{meta.input_type}, {meta.output_type}>({{",
            f"  method: '{meta.method}',",
            f"  path: '{meta.path}',",
            f"  hasPath: {'true' if meta.has_path else 'false'},",
            f"  hasBody: {'true' if meta.has_body else 'false'},",
        ]
        if meta.media_type is not None:
            lines.append(f"  mediaType: '{meta.media_type}',")
        lines.extend(
            [
                f"  response: '{meta.response_mode}',",
                "  key(input) {",
                f"    return {meta.key_expr};",
                "  },",
                "});",
            ]
        )
        return lines

    def _append_client_methods(self, meta: _OperationMetadata) -> None:
        self._client_methods.extend(
            [
                f"  async {meta.name}(input: {meta.input_type}): Promise<{meta.output_type}> {{",
                f"    return {meta.route_const}.request(this, input);",
                "  }",
                "",
                f"  {meta.name}Suspense(input: {meta.input_type}): SuspenseResource<{meta.output_type}> {{",
                f"    return {meta.route_const}.suspense(this, input);",
                "  }",
                "",
                f"  {meta.name}Loadable(input: {meta.input_type}): Loadable<{meta.output_type}> {{",
                f"    return {meta.route_const}.loadable(this, input);",
                "  }",
                "",
                f"  {meta.name}Query(",
                f"    input: {meta.input_type},",
                f"    options?: QueryOptions<{meta.output_type}>,",
                f"  ): QueryDescriptor<{meta.output_type}> {{",
                f"    return {meta.route_const}.query(this, input, options);",
                "  }",
                "",
            ]
        )

    def _render_routes_export(self) -> list[str]:
        lines = ["export const routes = {"]
        for name, const_name in self._route_handles:
            lines.append(f"  {name}: {const_name},")
        lines.append("} as const;")
        return lines

    def _render_client_class(self) -> list[str]:
        lines = [
            "export class ArtemisClient implements ArtemisClientRuntime {",
            "  private readonly baseUrl: string;",
            "  private readonly fetchImpl: typeof fetch;",
            "  private readonly defaultInit: RequestInit;",
            "",
            "  constructor(baseUrl: string, options: ClientOptions = {}) {",
            "    this.baseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;",
            "    this.fetchImpl = options.fetch ?? fetch;",
            "    this.defaultInit = options.init ?? {};",
            "  }",
            "",
            "  async request<I, O>(route: RouteRuntime<I, O>, input: I): Promise<O> {",
            "    const params = route.hasPath ? (input as Record<string, unknown>).path : undefined;",
            "    const resolved = route.hasPath",
            "      ? interpolatePath(route.path, params as Record<string, unknown>)",
            "      : route.path;",
            "    const url = new URL(resolved, this.baseUrl);",
            "    const init = this.composeInit(route, input);",
            "    const response = await this.fetchImpl(url.toString(), init);",
            "    if (!response.ok) {",
            "      throw new ArtemisHttpError(response);",
            "    }",
            "    return this.parseResponse(route, response);",
            "  }",
            "",
            "  private composeInit<I>(route: RouteRuntime<I, unknown>, input: I): RequestInit {",
            "    const override = (input as Record<string, unknown>).init as RequestInit | undefined;",
            "    const merged = mergeInit(this.defaultInit, override);",
            "    merged.method = route.method;",
            "    if (route.hasBody) {",
            "      const body = (input as Record<string, unknown>).body;",
            "      if (route.mediaType === 'application/json') {",
            "        merged.body = JSON.stringify(body ?? null);",
            "      } else if (body !== undefined) {",
            "        merged.body = body as BodyInit;",
            "      }",
            "      if (route.mediaType) {",
            "        merged.headers = mergeHeaders(merged.headers, { 'content-type': route.mediaType });",
            "      }",
            "    }",
            "    return merged;",
            "  }",
            "",
            "  private async parseResponse<I, O>(route: RouteRuntime<I, O>, response: Response): Promise<O> {",
            "    if (route.response === 'void') {",
            "      return undefined as O;",
            "    }",
            "    if (route.response === 'text') {",
            "      return (await response.text()) as unknown as O;",
            "    }",
            "    return (await response.json()) as O;",
            "  }",
        ]
        methods = list(self._client_methods)
        while methods and not methods[-1].strip():
            methods.pop()
        if methods:
            lines.append("")
            lines.extend(methods)
        lines.append("}")
        return lines

    def _response_type(self, response: Mapping[str, Any], status: str) -> tuple[str, str]:
        if status == "204" or not isinstance(response, Mapping):
            return "void", "void"
        content = response.get("content", {})
        if not content:
            return "void", "void"
        media, schema_wrapper = next(iter(content.items()))
        schema = schema_wrapper.get("schema", {})
        ts_type = self.renderer.render_type(schema)
        if media == "text/plain":
            return ts_type, "text"
        return ts_type, "json"


class _SchemaRenderer:
    def __init__(self, components: Mapping[str, Any]) -> None:
        self.components = components

    def render_component(self, name: str, schema: Mapping[str, Any]) -> list[str]:
        if schema.get("type") == "object" or schema.get("properties"):
            body = self.render_type(schema)
            return [f"export interface {name} {body}"]
        return [f"export type {name} = {self.render_type(schema)};"]

    def render_type(self, schema: Mapping[str, Any], level: int = 1) -> str:
        if "$ref" in schema:
            return schema["$ref"].split("/")[-1]
        if "anyOf" in schema:
            return " | ".join(self.render_type(item, level) for item in schema["anyOf"])
        if "enum" in schema:
            return " | ".join(json.dumps(value) for value in schema["enum"])
        if "const" in schema:
            return json.dumps(schema["const"])
        schema_type = schema.get("type")
        if isinstance(schema_type, list):
            return " | ".join(self.render_type({"type": item}) for item in schema_type)
        if schema_type == "object" or schema.get("properties"):
            return self._render_object(schema, level)
        if schema_type == "array":
            item_schema = schema.get("items", {})
            return f"Array<{self.render_type(item_schema, level)}>"
        if schema_type == "string":
            return "string"
        if schema_type == "integer" or schema_type == "number":
            return "number"
        if schema_type == "boolean":
            return "boolean"
        if schema_type == "null":
            return "null"
        return "unknown"

    def _render_object(self, schema: Mapping[str, Any], level: int) -> str:
        indent = "  " * level
        closing_indent = "  " * (level - 1)
        lines = ["{"]
        properties = schema.get("properties", {})
        required = set(schema.get("required", []))
        for key in sorted(properties):
            optional = "?" if key not in required else ""
            prop_type = self.render_type(properties[key], level + 1)
            lines.append(f"{indent}{key}{optional}: {prop_type};")
        additional = schema.get("additionalProperties")
        if additional:
            add_type = self.render_type(additional, level + 1)
            lines.append(f"{indent}[key: string]: {add_type};")
        lines.append(f"{closing_indent}}}")
        return "\n".join(lines)


def _sanitize_operation_id(operation_id: str) -> str:
    parts = [part for part in re.split(r"[^0-9a-zA-Z]+", operation_id) if part]
    if not parts:
        return "operation"
    head, *tail = parts
    candidate = head.lower() + "".join(segment.capitalize() for segment in tail)
    if candidate[0].isdigit():
        candidate = f"op_{candidate}"
    return candidate


def _type_name_from_path(path: str, method: str) -> str:
    tokens = [token for token in re.split(r"[^0-9a-zA-Z]+", path) if token]
    if not tokens:
        tokens = ["Root"]
    base = "".join(token.capitalize() for token in tokens)
    if base[0].isdigit():
        base = f"Route{base}"
    return f"{base}{method.title()}"


def _select_request_body(operation: Mapping[str, Any]) -> tuple[str, Mapping[str, Any]] | None:
    request_body = operation.get("requestBody")
    if not request_body:
        return None
    content = request_body.get("content", {})
    if "application/json" in content:
        schema = content["application/json"].get("schema", {})
        return "application/json", schema
    if content:
        media_type, value = next(iter(content.items()))
        return media_type, value.get("schema", {})
    return None


def _select_response(operation: Mapping[str, Any]) -> tuple[str, Mapping[str, Any]]:
    responses = operation.get("responses", {})
    if "200" in responses:
        return "200", responses["200"]
    for status in sorted(responses):
        if status.startswith("2"):
            return status, responses[status]
    return "200", {"description": "Success"}


__all__ = ["generate_typescript_client"]
