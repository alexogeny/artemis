"""Audit logging integration for ORM mutations and custom events."""

from __future__ import annotations

import datetime as dt
from contextlib import asynccontextmanager
from contextvars import ContextVar
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Callable, Mapping

import msgspec

from .tenancy import TenantContext
from .typing_utils import convert_primitive

if TYPE_CHECKING:  # pragma: no cover - imported for static typing only
    from .database import Database
    from .orm import ModelInfo, ModelRegistry


AuditAction = str
INSERT: AuditAction = "insert"
UPDATE: AuditAction = "update"
DELETE: AuditAction = "delete"
CUSTOM: AuditAction = "custom"


class AuditActor(msgspec.Struct, frozen=True, omit_defaults=True, kw_only=True):
    """Details about the subject responsible for an action."""

    id: str
    type: str
    attributes: Mapping[str, Any] = msgspec.field(default_factory=dict)


@dataclass(slots=True)
class AuditContext:
    """Context propagated across asynchronous ORM calls."""

    tenant: TenantContext | None
    actor: AuditActor | None


_AUDIT_CONTEXT: ContextVar[AuditContext | None] = ContextVar[AuditContext | None](
    "artemis_audit_context", default=None
)


@asynccontextmanager
async def audit_context(*, tenant: TenantContext | None, actor: AuditActor | None) -> Any:
    """Establish the active audit context for a request lifecycle."""

    token = _AUDIT_CONTEXT.set(AuditContext(tenant=tenant, actor=actor))
    try:
        yield
    finally:
        _AUDIT_CONTEXT.reset(token)


def current_context() -> AuditContext | None:
    """Return the currently bound :class:`AuditContext` if present."""

    return _AUDIT_CONTEXT.get()


def current_actor() -> AuditActor | None:
    """Return the actor captured in the current audit context."""

    context = current_context()
    return context.actor if context else None


def bind_actor(actor: AuditActor | None) -> None:
    """Update the active actor for the lifespan of the audit context."""

    context = current_context()
    if context is None:
        return
    context.actor = actor


class AuditTrail:
    """Persist audit log entries for ORM mutations and custom events."""

    def __init__(
        self,
        database: "Database",
        *,
        registry: "ModelRegistry | None" = None,
        clock: Callable[[], dt.datetime] | None = None,
    ) -> None:
        from .orm import default_registry  # local import to avoid cycle

        self.database = database
        self.registry = registry or default_registry()
        self._clock = clock or (lambda: dt.datetime.now(dt.timezone.utc))
        self._entry_models: dict[str, "ModelInfo[Any]"] = {}

    async def record_model_change(
        self,
        *,
        info: "ModelInfo[Any]",
        action: AuditAction,
        tenant: TenantContext | None,
        data: Mapping[str, Any],
        changes: Mapping[str, Any] | None = None,
        before: Mapping[str, Any] | None = None,
    ) -> None:
        """Record a change generated by the ORM."""

        entry_info = self._entry_info_for_scope(info.scope)
        actor = current_actor()
        payload = self._entry_payload(
            entry_info,
            action=action,
            entity_type=info.table,
            entity_id=self._identity_from_row(info, data),
            actor=actor,
            changes=self.sanitize_model_payload(info, changes or data),
            metadata=self._metadata_for(info=info, before=before, context=current_context()),
        )
        await self._write_entry(entry_info, payload, tenant if entry_info.scope == "tenant" else None)

    async def record_custom(
        self,
        *,
        scope: str,
        tenant: TenantContext | None,
        action: str,
        entity_type: str,
        entity_id: str | None = None,
        changes: Mapping[str, Any] | None = None,
        metadata: Mapping[str, Any] | None = None,
        actor: AuditActor | None = None,
    ) -> None:
        """Write a manually crafted audit entry."""

        entry_info = self._entry_info_for_scope(scope)
        payload = self._entry_payload(
            entry_info,
            action=action,
            entity_type=entity_type,
            entity_id=entity_id,
            actor=actor or current_actor(),
            changes=changes or {},
            metadata=self._metadata_for(info=None, before=None, context=current_context(), extra=metadata),
        )
        await self._write_entry(entry_info, payload, tenant if entry_info.scope == "tenant" else None)

    def _entry_info_for_scope(self, scope: str) -> "ModelInfo[Any]":
        if scope in self._entry_models:
            return self._entry_models[scope]
        if scope == "admin":
            from .models import AdminAuditLogEntry as entry_model
        else:
            from .models import TenantAuditLogEntry as entry_model
        info = self.registry.info_for(entry_model)
        self._entry_models[scope] = info
        return info

    def _entry_payload(
        self,
        info: "ModelInfo[Any]",
        *,
        action: AuditAction,
        entity_type: str,
        entity_id: str | None,
        actor: AuditActor | None,
        changes: Mapping[str, Any],
        metadata: Mapping[str, Any] | None,
    ) -> Mapping[str, Any]:
        now = self._clock()
        attributes = {
            "action": action,
            "entity_type": entity_type,
            "entity_id": entity_id,
            "actor_id": actor.id if actor else None,
            "actor_type": actor.type if actor else None,
            "changes": msgspec.to_builtins(changes),
            "metadata": metadata or {},
            "created_at": now,
            "updated_at": now,
        }
        if actor is not None:
            attributes["created_by"] = actor.id
            attributes["updated_by"] = actor.id
        model = info.model(**attributes)
        return {field.name: getattr(model, field.name) for field in info.fields}

    def sanitize_model_payload(
        self,
        info: "ModelInfo[Any]",
        payload: object,
    ) -> dict[str, Any]:
        """Remove sensitive fields from ``payload`` using model metadata."""

        builtins_payload = msgspec.to_builtins(payload)
        if not isinstance(builtins_payload, dict):
            return {}
        return {key: value for key, value in builtins_payload.items() if key not in info.redacted_fields}

    async def _write_entry(
        self,
        info: "ModelInfo[Any]",
        payload: Mapping[str, Any],
        tenant: TenantContext | None,
    ) -> None:
        from .database import _quote_identifier

        columns: list[str] = []
        values: list[Any] = []
        for field in info.fields:
            if field.name not in payload:
                continue
            columns.append(_quote_identifier(field.column))
            values.append(payload[field.name])
        if not columns:
            return
        placeholders = ", ".join(f"${idx}" for idx in range(1, len(values) + 1))
        schema = self.database.schema_for_model(info, tenant)
        table = f"{_quote_identifier(schema)}.{_quote_identifier(info.table)}"
        sql = f"INSERT INTO {table} ({', '.join(columns)}) VALUES ({placeholders})"
        async with self.database.connection_for_model(info, tenant=tenant) as connection:
            await connection.execute(sql, values)

    def _identity_from_row(self, info: "ModelInfo[Any]", row: Mapping[str, Any]) -> str | None:
        parts: list[str] = []
        for name in info.identity:
            value = row.get(name)
            if value is None:
                return None
            parts.append(str(convert_primitive(value, str, source=name)))
        return "::".join(parts) if parts else None

    def _metadata_for(
        self,
        *,
        info: "ModelInfo[Any] | None",
        before: Mapping[str, Any] | None,
        context: AuditContext | None,
        extra: Mapping[str, Any] | None = None,
    ) -> Mapping[str, Any]:
        metadata: dict[str, Any] = {}
        if extra:
            metadata.update(msgspec.to_builtins(extra))
        if before is not None:
            snapshot = msgspec.to_builtins(before)
            if info is not None:
                snapshot = self.sanitize_model_payload(info, snapshot)
            metadata["before"] = snapshot
        if context and context.tenant is not None:
            metadata.setdefault("tenant", context.tenant.tenant)
        return metadata


__all__ = [
    "CUSTOM",
    "DELETE",
    "INSERT",
    "UPDATE",
    "AuditAction",
    "AuditActor",
    "AuditTrail",
    "audit_context",
    "bind_actor",
    "current_actor",
    "current_context",
]
